<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A basic walk through · RobustVerificationSimulator.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RobustVerificationSimulator.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>A basic walk through</a><ul class="internal"><li><a class="tocitem" href="#Caveats"><span>Caveats</span></a></li></ul></li><li><span class="tocitem">Previous iterations and prototypig</span><ul><li><a class="tocitem" href="../protocol_version_01/">First protocol attemps</a></li><li><a class="tocitem" href="../graphs_01/">Working with graphs 01</a></li><li><a class="tocitem" href="../graphs_02/">Working with graphs 02</a></li><li><a class="tocitem" href="../graphs_03/">Working with graphs 03</a></li><li><a class="tocitem" href="../learning_brakets/">Learning to use QBase.jl</a></li><li><a class="tocitem" href="../symbolics_practice/">Experimenting with Symbolics.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>A basic walk through</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A basic walk through</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fieldofnodes/RobustVerificationSimulator.jl/blob/main/docs/src/WalkThrough.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Walk-through:-a-first-iteration"><a class="docs-heading-anchor" href="#Walk-through:-a-first-iteration">Walk through: a first iteration</a><a id="Walk-through:-a-first-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Walk-through:-a-first-iteration" title="Permalink"></a></h1><p>This walk through is not meant to be compelted code, in fact it is not. I am still working on this functionality. I am developing an algorithm based off of the paper linked in the <code>README.md</code> of this repository. The manner in which this project is being developed can be described as iterative. This means that the code presented here, once completed, will not yield an MBQC which can execute the protocal. This version will simply lay out the broad strokes of the processes. If a piece of functionality is not completed, then I place holder function will be used.</p><p>To emulate this verification protocol. Start by activating your local project</p><pre><code class="language-julia hljs">using Pkg
Pkg.activate(&quot;.&quot;)</code></pre><p>If <code>RobustVerificationSimulator.jl</code>has not been installed, then</p><pre><code class="language-julia hljs">] add https://github.com/fieldofnodes/RobustVerificationSimulator.jl</code></pre><p>then</p><pre><code class="language-julia hljs">using RobustVerificationSimulator</code></pre><p>We simulate a random graph to represent our circuit with the following values.</p><pre><code class="language-julia hljs">p₁ = p₂ = 0.5
N = 1000
v = 5
e = 8
reps=100</code></pre><p>Here <code>p₁</code> and <code>p₂</code> are probability values used for stochastic sampling while the simulator software is being developed. Once completed this functionality will be replaced with the appropriate function calls. The number of rounds is represented by <code>N</code>, <code>v</code> and <code>e</code> represent the number of vertices and edges in the graph. In the circuit each <code>v</code> is a qubit and each <code>e</code> is the <code>CZ</code> gate establishing entanglement between the qubits. Finally <code>reps</code> is the number of repetitions used to approximate a graph colouring.</p><pre><code class="language-julia hljs">graph_for_client = generate_simple_graph(v,e)</code></pre><p>We generate a graph with <code>v</code> vertices and <code>e</code> edges. For the time being this graph is contructed randomly. We call this &#39;graph<em>for</em>client` to indicate this graph is still on the client side of the protocol. Once we are ready to send this graph to the server, we then bound the graph to a different label, namely an indication that the graph is for the server.</p><p>The output</p><pre><code class="language-julia hljs">{5, 8} undirected simple Int64 graph</code></pre><p>We take <code>graph_for_client</code> and convert it to a <code>MetaGraph</code>, this is a graph which allow properties to be set to the graph, qubits or edges. As we have not implemented the quantum simulator yet, we construct this meta graph. These properties attached can be the angles and the qubit type. This graph is prepared for the <code>Computation</code> round. The graph associated with the <code>Test</code> rounds will be generated in a <code>for</code> loop. </p><pre><code class="language-julia hljs">meta_graph_for_client = @chain graph_for_client begin
    MetaGraph(_)
    generate_property_graph!(_,Computation())
end</code></pre><p>The output</p><pre><code class="language-julia hljs">{5, 8} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0)</code></pre><pre><code class="language-julia hljs">g_cols = generate_random_greedy_color(graph_for_client,reps)    </code></pre><p>Here <code>g_cols</code> is the coloring of <code>graph_for_client</code> which is optimised over the <code>reps</code></p><p>The output</p><pre><code class="language-julia hljs">Graphs.Coloring{Int64}(3, [1, 3, 2, 3, 1])</code></pre><p>The first element, <code>3</code>, represents the number of colors, and <code>[1, 3, 2, 3, 1]</code> represents the coloring. We then need to separate each colour and bind it to another graph for our <code>Test</code> rounds.</p><p>We can run</p><pre><code class="language-julia hljs">contruct_coloring_plot_for_all_colors(graph_for_client,g_cols.colors)</code></pre><p>to get a plot for the colouring.</p><p><img src="../assets/example_colouring.png" alt="colouring"/></p><pre><code class="language-julia hljs">g_diff_cols = separate_each_color(g_cols)</code></pre><p>We create a <code>g_diff_cols</code> a vector of vectors, each one is a different colouring of the graph.</p><pre><code class="language-julia hljs">3-element Vector{Vector{Int64}}:
 [2, 1, 1, 1, 2]
 [1, 1, 2, 1, 1]
 [1, 2, 1, 2, 1]</code></pre><p>Each vector is a different colouring. The top vector <code>[2, 1, 1, 1, 2]</code> is a single colour set. Elements that are <code>1</code> are the <code>Dummy</code> qubits and <code>2</code> are the <code>Test</code> qubits. As an example of a individual colouring</p><p><img src="../assets/example_single_colour.png" alt="single colour"/></p><p>Next we move into the construction of the rounds. Here we select the <code>N</code> rounds from above. We will iterate from <code>1</code> to <code>N</code> and for the time, at each iteration we will select with probability <code>p₁</code> whether the round is a <code>Test</code> or a <code>Computation</code>. We note that the <code>Redo</code> function has not been implemented yet. We also need to construct the actual quantum simulator for qubit and gate construction. </p><p>For now consider this an overview what is being completed in client-side preparation.</p><pre><code class="language-julia hljs">graphs_for_server = []
for i in Base.OneTo(N)
    round_type = choose_test_computation(p₁)
    if round_type isa Test
        # Create property graph
        client_process_graph = MetaGraph(graph_for_client)
        # Add round type
        set_prop!(client_process_graph, :round_type, Test())
        # Sample colouring
        trap_dummy_vector = get_random_coloring(g_diff_cols)
        # Generate trap/test graph
        generate_property_graph!(client_process_graph,round_type,trap_dummy_vector)
        # Make copy of 
        graph_for_server = copy(client_process_graph)
        # Remove secrete properties of client graph
        #rem_prop!(mgraphs_for_server, 1, :name)
        # Verify bᵥ = rᵥ ⊕ dᵥ 
        #   for v ∈ Trap and N(v) ∈ Dummy, 
        #   dᵥ = ⨁ᵢ ∈ N(v) dᵢ
        # Outcome for round = 
        #   1 for bᵥ = rᵥ ⊕ dᵥ is true and 
        #   0 for bᵥ = rᵥ ⊕ dᵥ  is false
        # Get outcome for round
        set_prop!(client_process_graph, 
            :round_outcome, compare_trap_test())
        # Return bᵥ
    elseif round_type isa Computation
        client_process_graph = copy(meta_graph_for_client)
        set_prop!(client_process_graph, :round_type, Computation())
        set_prop!(client_process_graph, 
            :round_outcome, rand_int())
    else
        error_call_not_test_computation()
    end        

    push!(graphs_for_server,graph_for_server)
end</code></pre><ol><li>We create an empty vector <code>graphs_for_server = []</code>, this is to be considered the graphs that are to be sent to the server.</li><li>We have three paths,<ul><li>The round is a <code>Test</code></li><li>The round is a <code>Computation</code></li><li>A safety error is thrown if there is some bug.</li></ul></li><li>For <code>Test</code><ul><li>We create a property graph</li><li>We prototyping and round evaluation we add the round type to the graph.</li><li>We sample uniformly from our set of different graph colour configurations.</li><li>We generated the <code>Trap</code> and <code>Dummy</code> graph and add attributes per vertex.</li><li>We make a copy of this graph.<ul><li>One copy is for the client</li><li>One copy, which is stripped of secret properties, is sent to the server.</li></ul></li><li>The server returns bᵥ and we verify <ul><li>bᵥ = rᵥ ⊕ dᵥ</li><li>for v ∈ Trap and N(v) ∈ Dummy,</li></ul>dᵥ = ⨁ᵢ ∈ N(v) dᵢ<ul><li>These were generated when we generated the <code>Trap</code> and <code>Dummy</code> graph. </li><li>Outcome for round:</li><li>1 for bᵥ = rᵥ ⊕ dᵥ is true and </li><li>0 for bᵥ = rᵥ ⊕ dᵥ  is false</li><li>Store round outcome</li></ul></li></ul></li><li>For <code>Computation</code><ul><li>We generate 2 copies of the client graph</li><li>We add the round type to one of the  property graphs and save</li><li>We send a public graph to the server to obtain results.</li><li>At the moment we simple choose at random <code>0</code> or <code>1</code> the result.<ul><li>This is a temporary place holder.</li></ul></li></ul></li></ol><p>This is the current workflow which I have developed in part to help me understand the workflow of the verificatation protocol. I am still learning it.</p><h2 id="Caveats"><a class="docs-heading-anchor" href="#Caveats">Caveats</a><a id="Caveats-1"></a><a class="docs-heading-anchor-permalink" href="#Caveats" title="Permalink"></a></h2><p>This model illustrates incompletely and very roughly the process for preparing a graph which is meant to represet the MBQC circuit and to obtain some results. In this current state the results and even the correctness of the model is not importatn. The important component is building the first layer. This first layer is set to roughly convert the verification protocol into working code. </p><p>The next few steps are to flush out the remainder of the protocol so that we can prepare a theoretical symbolic state of a qubit, &quot;send&quot; it to a &quot;server&quot; and measure it along the appropratie basis, then draw with the correct probabtility the outcome measurement. This will again not be the completed project, but an iteration in which a further detail of the protocol is further converted into working code.</p><p>Either in tandem or once this is completed, an MBQC simulator needs to be developed to execute this protocol in a simulation. These progress points will only be dealing with the internal mechanisms of the protocol and will say nothing of a modular algorithm that needs to be developed.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../protocol_version_01/">First protocol attemps »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 21 February 2023 04:31">Tuesday 21 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
