var documenterSearchIndex = {"docs":
[{"location":"symbolics_practice/#Synbolics","page":"Experimenting with Symbolics.jl","title":"Synbolics","text":"","category":"section"},{"location":"symbolics_practice/","page":"Experimenting with Symbolics.jl","title":"Experimenting with Symbolics.jl","text":"It is possible to use julia for symbolic algedbra. As I was working through my understanding of the protocal, I wondered if it would be useful to have some symbolic representaion of the BraKet algebra. I have not progressed very far.","category":"page"},{"location":"symbolics_practice/","page":"Experimenting with Symbolics.jl","title":"Experimenting with Symbolics.jl","text":"using Pkg\nPkg.activate(\".\")\nusing Symbolics\n@variables ϕᵥ k sᵥˣ sᵥᶻ rᵥ xᵥ\n\n\"\"\"\n    Computation\n    v∈I\n    Client: θ̃ᵥ = θᵥ + xᵥπ\n    xᵥ: Stored choicxe for {0,1}\n        Needed for recovering the original angle\n    δᵥ = ϕᵥ′ + θ̃ᵥ + rᵥπ \n\"\"\"\nϕᵥ′ = (-1)^sᵥˣ*ϕᵥ+sᵥᶻ*Num(π)\nθᵥ =  k*Num(π)/4\nθ̃ᵥ = θᵥ + xᵥ*Num(π)\nrπ = rᵥ*Num(π)    \nδᵥ = ϕᵥ′ + θ̃ᵥ + rπ \n\n\"\"\"\n    Test\n    v∉Vⱼ\n    Client: δᵥ = {k|k∼U(0..7) : kπ/4}\n    v∈V\n    Client: δᵥ = θᵥ + rᵥπ, rᵥ∼U(0..1)\n\"\"\"\n# v∉Vⱼ\nθᵥ =  k*Num(π)/4\nδᵥ = θᵥ\n#v∈V\nrπ = rᵥ*Num(π)    \nθᵥ =  k*Num(π)/4\nδᵥ = θᵥ + rπ\n\n\n\n\"\"\"\n   Substitutions\n\"\"\"\nsubstitute(δᵥ,Dict(ϕᵥ => π/4, k => 1, sᵥˣ => 1, sᵥᶻ => 1, rᵥ => 1)) \nsubstitute(rπ,Dict(rᵥ => 1))\n\n\n\"\"\"\n    I still need to build the \"sending to server part\" \n    I send δᵥ to the server and the server send back bᵥ\n\"\"\"\n","category":"page"},{"location":"graphs_02/#Graph-prototyping-version-02","page":"Working with graphs 02","title":"Graph prototyping version 02","text":"","category":"section"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"This is a simple script I developed to get further familiar with the Graphs.jl API.","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"```julia \"\"\"    Load packages \"\"\" using Pkg Pkg.activate(\".\") using Graphs using Plots using GraphRecipes using Colors using Chain","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"\"\"\"    Load functions \"\"\" include(\"src/graph_functions.jl\")","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"\"\"\"     Define number of vertices, edges and reps.     vertices: The number of vertices in a graph     edges: The number of edges in a graph     reps: The number of reps used to get the best           coloring of a given graph G. \"\"\" v = 5 e = 8 reps=100","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"g = generatesimplegraph(v,e) gcols = generaterandomgreedycolor(g,reps)     gdiffcols = separateeachcolor(gcols) gcol = getrandomcoloring(gdiffcols)","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"p = [contructcoloringplotforonecolor(g,co) for co in gdiff_cols]","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"[savefig(p[i],\"figs/graphcoloringexampleeachgraph_i.png\") for i in eachindex(p)]","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"pfullcolor = graphplot(g,          curves=false,          nodecolor = g_cols.colors,         nodesize = 0.3,         edgecolor=:skyblue1,         nodestrokecolor = :skyblue1,         edgewidth = (s,d,w)->1.5)","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"savefig(pfullcolor,\"figs/graphcoloringexample.png\")","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"graphsforserver[5].vprops graphsforserver[5] |> typeof |> fieldnames","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"qubitmetagraph = graphsforserver[1] round = qubitmetagraph.gprops[:round_type]","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"for v ∈ vertices(qubitmetagraph)     vertextype = qubitmetagraph.vprops[v][:qubittype]     δvalue = computeδᵥ(round,vertextype)         setprop!(qubitmetagraph,v,:δᵥ,δ_value) end","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"qubitmetagraph.vprops","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"\"\"\"     Figure out how to do the redo round \"\"\"","category":"page"},{"location":"graphs_02/#Test-redo","page":"Working with graphs 02","title":"Test redo","text":"","category":"section"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"samesies = [] p = 0.5         for i in 1:N     u₁ = rand()     u₂ = do_redo(u₁,p)     res = u₁ == u₂     push!(samesies,res) end","category":"page"},{"location":"graphs_02/#graph-construction-and-coloring","page":"Working with graphs 02","title":"graph construction and coloring","text":"","category":"section"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"\"\"\"     Draw randomly a string kπ/4 for k ∈ 0..7 \"\"\" function θᵥ()         k = rand(0:7)     if k == 0         return string(\"0\")     else         return string(k,\"π/4\")     end end","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"\"\"\"     ComputationRound() -> get kπ/4 k∈0..7 \"\"\" function qubit_information(::ComputationRound)         return string(\"|+\",θᵥ(),\">\") end","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"rᵥπ() = string(rand([0,1]),\"π\")","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"δᵥ = ϕᵥ′ + θᵥ() + rᵥ()π","category":"page"},{"location":"graphs_02/","page":"Working with graphs 02","title":"Working with graphs 02","text":"````","category":"page"},{"location":"graphs_01/#Graph-prototyping-version-01","page":"Working with graphs 01","title":"Graph prototyping version 01","text":"","category":"section"},{"location":"graphs_01/","page":"Working with graphs 01","title":"Working with graphs 01","text":"This is a simple script I developed to get familiar with the Graphs.jl API.","category":"page"},{"location":"graphs_01/","page":"Working with graphs 01","title":"Working with graphs 01","text":"```julia using Pkg Pkg.activate(\".\") using Graphs using Plots using GraphRecipes using Colors using Chain","category":"page"},{"location":"graphs_01/","page":"Working with graphs 01","title":"Working with graphs 01","text":"// # Functions     \"\"\"         From number of vertices and edges -> Graph     \"\"\"     function generatesimplegraph(v,e)         return SimpleGraph(v,e)     end","category":"page"},{"location":"graphs_01/","page":"Working with graphs 01","title":"Working with graphs 01","text":"\"\"\"\n    Use Graphs.random_greedy_color(g, reps) -> Graphs.Coloring{Int64}\n    Uses a greedy approximation to get a colouring of a graph\n\"\"\"\nfunction generate_random_greedy_color(g,reps)\n    return Graphs.random_greedy_color(g, reps)\nend\n\n\n\"\"\"\n    Extracts from a Graphs.Coloring{Int64} -> Vector{Vector{Int64}}\n    Once a coloring is selected a vector of integers will result\n    1 -> DummyQubit vertex\n    2 -> Trap\n\"\"\"\nfunction separate_each_color(g::Graphs.Coloring{Int64})\n    colouring = map(x-> Int.(g.colors .== x).+1,Base.OneTo(g.num_colors))\n    return colouring\nend\n\n\"\"\"\n    Extracts from Vector{Vector{Int64}} -> Vector{Int64}\n    Draw uniform one colouring arangments\n\"\"\"\nfunction get_random_coloring(c::Vector{Vector{Int64}})\n    return rand(c)\nend","category":"page"},{"location":"graphs_01/","page":"Working with graphs 01","title":"Working with graphs 01","text":"//","category":"page"},{"location":"graphs_01/","page":"Working with graphs 01","title":"Working with graphs 01","text":"\"\"\"     Define number of vertices, edges and reps.     vertices: The number of vertices in a graph     edges: The number of edges in a graph     reps: The number of reps used to get the best           coloring of a given graph G. \"\"\" v = 5 e = 8 reps=100","category":"page"},{"location":"graphs_01/","page":"Working with graphs 01","title":"Working with graphs 01","text":"g = generatesimplegraph(v,e) gcols = generaterandomgreedycolor(g,reps)     gdiffcols = separateeachcolor(gcols) gcol = getrandomcoloring(gdiffcols)","category":"page"},{"location":"graphs_01/","page":"Working with graphs 01","title":"Working with graphs 01","text":"contructcoloringplotforallcolors(g,gcols.colors) contructcoloringplotforonecolor(g,gcol)","category":"page"},{"location":"graphs_01/","page":"Working with graphs 01","title":"Working with graphs 01","text":"````","category":"page"},{"location":"graphs_03/#Graph-prototyping-version-02","page":"Working with graphs 03","title":"Graph prototyping version 02","text":"","category":"section"},{"location":"graphs_03/","page":"Working with graphs 03","title":"Working with graphs 03","text":"This is a simple script I developed to get further familiar with the Graphs.jl API.","category":"page"},{"location":"graphs_03/","page":"Working with graphs 03","title":"Working with graphs 03","text":"using Pkg\nPkg.activate(\".\")\n\nusing Statistics \nusing CairoMakie\nusing Graphs\nusing Plots\nusing GraphRecipes\nusing Colors\nusing Chain\nusing MetaGraphs\n\n\n\ninclude(\"stucts_types.jl\")\ninclude(\"protocol_functions.jl\")\ninclude(\"graph_functions.jl\")\ninclude(\"helper_functions.jl\")\ninclude(\"compute_delta_v_functions.jl\")\ninclude(\"generate_qubit_property_graph.jl\")\n\n\n\nv = 5\ne = 8\nreps=100\n\n\ng = generate_simple_graph(v,e)\ncols = generate_random_greedy_color(g,reps)    \ndiff_cols = separate_each_color(cols)\n\n\n\ngp₁ = contruct_coloring_plot_for_no_colors(g)\ngp₂ = contruct_coloring_plot_for_all_colors(g,cols.colors)\ngp₃ₙ = [contruct_coloring_plot_for_one_color(g,gc) for gc in diff_cols]\nlen₃ₙ = length(diff_cols)\ngps = reduce(vcat,[gp₁,gp₂,gp₃ₙ])\nl₁₂ = [\"no_colouring\",\"colouring\"]\nl₃ₙ = [\"single_colour_$(i)\" for i in Base.OneTo(len₃ₙ)]\nls = string.(\"figs/\",reduce(vcat,[l₁₂,l₃ₙ]),\".png\")\nsavefig.(gps,ls)\n","category":"page"},{"location":"WalkThrough/#Walk-through:-a-first-iteration","page":"A basic walk through","title":"Walk through: a first iteration","text":"","category":"section"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"This walk through is not meant to be compelted code, in fact it is not. I am still working on this functionality. I am developing an algorithm based off of the paper linked in the README.md of this repository. The manner in which this project is being developed can be described as iterative. This means that the code presented here, once completed, will not yield an MBQC which can execute the protocal. This version will simply lay out the broad strokes of the processes. If a piece of functionality is not completed, then I place holder function will be used.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"To emulate this verification protocol. Start by activating your local project","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"If RobustVerificationSimulator.jlhas not been installed, then","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"] add https://github.com/fieldofnodes/RobustVerificationSimulator.jl","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"then","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"using RobustVerificationSimulator","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"We simulate a random graph to represent our circuit with the following values.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"p₁ = p₂ = 0.5\nN = 1000\nv = 5\ne = 8\nreps=100","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"Here p₁ and p₂ are probability values used for stochastic sampling while the simulator software is being developed. Once completed this functionality will be replaced with the appropriate function calls. The number of rounds is represented by N, v and e represent the number of vertices and edges in the graph. In the circuit each v is a qubit and each e is the CZ gate establishing entanglement between the qubits. Finally reps is the number of repetitions used to approximate a graph colouring.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"graph_for_client = generate_simple_graph(v,e)","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"We generate a graph with v vertices and e edges. For the time being this graph is contructed randomly. We call this 'graphforclient` to indicate this graph is still on the client side of the protocol. Once we are ready to send this graph to the server, we then bound the graph to a different label, namely an indication that the graph is for the server.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"The output","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"{5, 8} undirected simple Int64 graph","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"We take graph_for_client and convert it to a MetaGraph, this is a graph which allow properties to be set to the graph, qubits or edges. As we have not implemented the quantum simulator yet, we construct this meta graph. These properties attached can be the angles and the qubit type. This graph is prepared for the Computation round. The graph associated with the Test rounds will be generated in a for loop. ","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"meta_graph_for_client = @chain graph_for_client begin\n    MetaGraph(_)\n    generate_property_graph!(_,ComputationRound())\nend","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"The output","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"{5, 8} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0)","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"g_cols = generate_random_greedy_color(graph_for_client,reps)    ","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"Here g_cols is the coloring of graph_for_client which is optimised over the reps","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"The output","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"Graphs.Coloring{Int64}(3, [1, 3, 2, 3, 1])","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"The first element, 3, represents the number of colors, and [1, 3, 2, 3, 1] represents the coloring. We then need to separate each colour and bind it to another graph for our Test rounds.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"We can run","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"contruct_coloring_plot_for_all_colors(graph_for_client,g_cols.colors)","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"to get a plot for the colouring.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"(Image: colouring)","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"g_diff_cols = separate_each_color(g_cols)","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"We create a g_diff_cols a vector of vectors, each one is a different colouring of the graph.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"3-element Vector{Vector{Int64}}:\n [2, 1, 1, 1, 2]\n [1, 1, 2, 1, 1]\n [1, 2, 1, 2, 1]","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"Each vector is a different colouring. The top vector [2, 1, 1, 1, 2] is a single colour set. Elements that are 1 are the DummyQubit qubits and 2 are the Test qubits. As an example of a individual colouring","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"(Image: single colour)","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"Next we move into the construction of the rounds. Here we select the N rounds from above. We will iterate from 1 to N and for the time, at each iteration we will select with probability p₁ whether the round is a Test or a Computation. We note that the Redo function has not been implemented yet. We also need to construct the actual quantum simulator for qubit and gate construction. ","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"For now consider this an overview what is being completed in client-side preparation.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"graphs_for_server = []\nfor i in Base.OneTo(N)\n    round_type = choose_test_computation(p₁)\n    if round_type isa Test\n        # Create property graph\n        client_process_graph = MetaGraph(graph_for_client)\n        # Add round type\n        set_prop!(client_process_graph, :round_type, TestRound())\n        # Sample colouring\n        trap_dummy_vector = get_random_coloring(g_diff_cols)\n        # Generate trap/test graph\n        generate_property_graph!(client_process_graph,round_type,trap_dummy_vector)\n        # Make copy of \n        graph_for_server = copy(client_process_graph)\n        # Remove secrete properties of client graph\n        #rem_prop!(mgraphs_for_server, 1, :name)\n        # Verify bᵥ = rᵥ ⊕ dᵥ \n        #   for v ∈ Trap and N(v) ∈ DummyQubit, \n        #   dᵥ = ⨁ᵢ ∈ N(v) dᵢ\n        # Outcome for round = \n        #   1 for bᵥ = rᵥ ⊕ dᵥ is true and \n        #   0 for bᵥ = rᵥ ⊕ dᵥ  is false\n        # Get outcome for round\n        set_prop!(client_process_graph, \n            :round_outcome, compare_trap_test())\n        # Return bᵥ\n    elseif round_type isa Computation\n        client_process_graph = copy(meta_graph_for_client)\n        set_prop!(client_process_graph, :round_type, ComputationRound())\n        set_prop!(client_process_graph, \n            :round_outcome, rand_int())\n    else\n        error_call_not_test_computation()\n    end        \n\n    push!(graphs_for_server,graph_for_server)\nend","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"We create an empty vector graphs_for_server = [], this is to be considered the graphs that are to be sent to the server.\nWe have three paths,\nThe round is a Test\nThe round is a Computation\nA safety error is thrown if there is some bug.\nFor Test\nWe create a property graph\nWe prototyping and round evaluation we add the round type to the graph.\nWe sample uniformly from our set of different graph colour configurations.\nWe generated the Trap and DummyQubit graph and add attributes per vertex.\nWe make a copy of this graph.\nOne copy is for the client\nOne copy, which is stripped of secret properties, is sent to the server.\nThe server returns bᵥ and we verify \nbᵥ = rᵥ ⊕ dᵥ\nfor v ∈ Trap and N(v) ∈ DummyQubit,\ndᵥ = ⨁ᵢ ∈ N(v) dᵢ\nThese were generated when we generated the Trap and DummyQubit graph. \nOutcome for round:\n1 for bᵥ = rᵥ ⊕ dᵥ is true and \n0 for bᵥ = rᵥ ⊕ dᵥ  is false\nStore round outcome\nFor Computation\nWe generate 2 copies of the client graph\nWe add the round type to one of the  property graphs and save\nWe send a public graph to the server to obtain results.\nAt the moment we simple choose at random 0 or 1 the result.\nThis is a temporary place holder.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"This is the current workflow which I have developed in part to help me understand the workflow of the verificatation protocol. I am still learning it.","category":"page"},{"location":"WalkThrough/#Caveats","page":"A basic walk through","title":"Caveats","text":"","category":"section"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"This model illustrates incompletely and very roughly the process for preparing a graph which is meant to represet the MBQC circuit and to obtain some results. In this current state the results and even the correctness of the model is not importatn. The important component is building the first layer. This first layer is set to roughly convert the verification protocol into working code. ","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"The next few steps are to flush out the remainder of the protocol so that we can prepare a theoretical symbolic state of a qubit, \"send\" it to a \"server\" and measure it along the appropratie basis, then draw with the correct probabtility the outcome measurement. This will again not be the completed project, but an iteration in which a further detail of the protocol is further converted into working code.","category":"page"},{"location":"WalkThrough/","page":"A basic walk through","title":"A basic walk through","text":"Either in tandem or once this is completed, an MBQC simulator needs to be developed to execute this protocol in a simulation. These progress points will only be dealing with the internal mechanisms of the protocol and will say nothing of a modular algorithm that needs to be developed.","category":"page"},{"location":"#RobustVerification.jl","page":"Home","title":"RobustVerification.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"    CurrentModule = RobustVerificationSimulator","category":"page"},{"location":"#Structs","page":"Home","title":"Structs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    Redo","category":"page"},{"location":"#RobustVerificationSimulator.Redo","page":"Home","title":"RobustVerificationSimulator.Redo","text":"Redo round type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"    Test","category":"page"},{"location":"#RobustVerificationSimulator.Test","page":"Home","title":"RobustVerificationSimulator.Test","text":"Round Test type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"    Computation","category":"page"},{"location":"#RobustVerificationSimulator.Computation","page":"Home","title":"RobustVerificationSimulator.Computation","text":"Round Computation type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"    Trap","category":"page"},{"location":"#RobustVerificationSimulator.Trap","page":"Home","title":"RobustVerificationSimulator.Trap","text":"Qubit Trap type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"    DummyQubit","category":"page"},{"location":"#RobustVerificationSimulator.DummyQubit","page":"Home","title":"RobustVerificationSimulator.DummyQubit","text":"Qubit DummyQubit type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"    ComputationQubit","category":"page"},{"location":"#RobustVerificationSimulator.ComputationQubit","page":"Home","title":"RobustVerificationSimulator.ComputationQubit","text":"Qubit ComputationQubit type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"    InputQubit","category":"page"},{"location":"#RobustVerificationSimulator.InputQubit","page":"Home","title":"RobustVerificationSimulator.InputQubit","text":"Qubit InputQubit type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"    NotInputQubit","category":"page"},{"location":"#RobustVerificationSimulator.NotInputQubit","page":"Home","title":"RobustVerificationSimulator.NotInputQubit","text":"Qubit NotInputQubit type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"    Ok","category":"page"},{"location":"#RobustVerificationSimulator.Ok","page":"Home","title":"RobustVerificationSimulator.Ok","text":"Round outcome type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"    Abort","category":"page"},{"location":"#RobustVerificationSimulator.Abort","page":"Home","title":"RobustVerificationSimulator.Abort","text":"Round Abort type\n\n\n\n\n\n","category":"type"},{"location":"#Graph-based-functions","page":"Home","title":"Graph based functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    generate_simple_graph","category":"page"},{"location":"#RobustVerificationSimulator.generate_simple_graph","page":"Home","title":"RobustVerificationSimulator.generate_simple_graph","text":"From number of vertices and edges (v,e)-> Graph\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    generate_random_greedy_color","category":"page"},{"location":"#RobustVerificationSimulator.generate_random_greedy_color","page":"Home","title":"RobustVerificationSimulator.generate_random_greedy_color","text":"Use Graphs.randomgreedycolor(g, reps) -> Graphs.Coloring{Int64} Uses a greedy approximation to get a colouring of a graph\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    separate_each_color","category":"page"},{"location":"#RobustVerificationSimulator.separate_each_color","page":"Home","title":"RobustVerificationSimulator.separate_each_color","text":"Extracts from a Graphs.Coloring{Int64} -> Vector{Vector{Int64}} Once a coloring is selected a vector of integers will result 1 -> DummyQubit vertex 2 -> Trap\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    get_random_coloring","category":"page"},{"location":"#RobustVerificationSimulator.get_random_coloring","page":"Home","title":"RobustVerificationSimulator.get_random_coloring","text":"Extracts from Vector{Vector{Int64}} -> Vector{Int64} Draw uniform one colouring arangments\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    generate_property_graph!","category":"page"},{"location":"#RobustVerificationSimulator.generate_property_graph!","page":"Home","title":"RobustVerificationSimulator.generate_property_graph!","text":"From (MetaGraph{Int64, \n    Union{TestRound,ComputationRound},\n    Float64},Vector{Int64}) - >\n        MetaGraph{Int64, Float64}\nThe random approximate independnet set  is used to label the graph\nAccording to the Trap and DummyQubit\nThis function affects the input meta graph so it had a !\nFor Trap a random angle is sent over\nFor DummyQubit random 0 or 1\n\n\n\n\n\nFrom (MetaGraph{Int64, Float64},Union{TestRound,ComputationRound}) - >\n        MetaGraph{Int64, Float64}\nTake SimpleGraph, just converted to MetaGraph and add angles.\nNote: this may be a temporary solutions, I need to implement \nan input and output set for the vertices\n\n\n\n\n\n","category":"function"},{"location":"#Plot-graph-colourings","page":"Home","title":"Plot graph colourings","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    contruct_coloring_plot_for_one_color","category":"page"},{"location":"#RobustVerificationSimulator.contruct_coloring_plot_for_one_color","page":"Home","title":"RobustVerificationSimulator.contruct_coloring_plot_for_one_color","text":"Plot graph g with the random coloring stipulated from functions:\n1. generate_random_greedy_color\n2. g_col = get_random_coloring\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    contruct_coloring_plot_for_all_colors","category":"page"},{"location":"#RobustVerificationSimulator.contruct_coloring_plot_for_all_colors","page":"Home","title":"RobustVerificationSimulator.contruct_coloring_plot_for_all_colors","text":"Plot graph g with the random coloring stipulated from functions:\n1. generate_random_greedy_color\n2. g_col = get_random_coloring\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    contruct_coloring_plot_for_no_colors","category":"page"},{"location":"#RobustVerificationSimulator.contruct_coloring_plot_for_no_colors","page":"Home","title":"RobustVerificationSimulator.contruct_coloring_plot_for_no_colors","text":"Plot graph whith no coloring\n\n\n\n\n\n","category":"function"},{"location":"#Round-functions","page":"Home","title":"Round functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Including functions dealing with  Computation or Test and further for Trap or DummyQubit qubit tyes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"    choose_test_computation","category":"page"},{"location":"#RobustVerificationSimulator.choose_test_computation","page":"Home","title":"RobustVerificationSimulator.choose_test_computation","text":"InputQubit a probability -> Union{TestRound,ComputationRound}\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    return_ok_or_abort","category":"page"},{"location":"#RobustVerificationSimulator.return_ok_or_abort","page":"Home","title":"RobustVerificationSimulator.return_ok_or_abort","text":"InputQubit a probability -> Union{OK,Abort}\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    get_round_result","category":"page"},{"location":"#RobustVerificationSimulator.get_round_result","page":"Home","title":"RobustVerificationSimulator.get_round_result","text":"Take (round_type,p) -> Union{OK,Abort}\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    qubit_information","category":"page"},{"location":"#RobustVerificationSimulator.qubit_information","page":"Home","title":"RobustVerificationSimulator.qubit_information","text":"TrapQubit() -> get kπ/4 k∈0..7\n\n\n\n\n\nDummyQubit() -> 0,1\n\n\n\n\n\nComputationRound() -> get kπ/4 k∈0..7\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    compare_trap_test","category":"page"},{"location":"#RobustVerificationSimulator.compare_trap_test","page":"Home","title":"RobustVerificationSimulator.compare_trap_test","text":"Function, which will iterate over vertices\nwill yield if the round passed or failed\n\n\n\n\n\n","category":"function"},{"location":"#Redo-function","page":"Home","title":"Redo function","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    do_redo","category":"page"},{"location":"#RobustVerificationSimulator.do_redo","page":"Home","title":"RobustVerificationSimulator.do_redo","text":"InputQubit two proabailites (u,p) -> u\nIf uₜₑₛₜ < p -> draw new u ~ U(0,1)\nelse return u\n\n\n\n\n\n","category":"function"},{"location":"#Compute-angle-function","page":"Home","title":"Compute angle function","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    compute_δᵥ","category":"page"},{"location":"#RobustVerificationSimulator.compute_δᵥ","page":"Home","title":"RobustVerificationSimulator.compute_δᵥ","text":"Computation of δᵥ Case\n\nRound ≡ Test ∩ Qubit ≡ DummyQubit  → δᵥ = {kπ/r | k ∼ U(0..7)}\n\n\n\n\n\nComputation of δᵥ Case\n\nRound ≡ Test ∩ Qubit ≡ Trap  → δᵥ = θᵥ + rᵥπ\n\n\n\n\n\nComputation of δᵥ Case\n\nRound ≡ Computation ∩ Qubit ∈ InputQubit set  → δᵥ = ϕᵥ + (θᵥ + xᵥπ) + rᵥπ\n\n\n\n\n\nComputation of δᵥ Case\n\nRound ≡ Computation ∩ Qubiut ∉ InputQubit set  → δᵥ = ϕᵥ′ + θᵥ + rᵥπ\n\n\n\n\n\nTemporary function till I implement/figure out the      input/output set Computation of δᵥ Case\n\nRound ≡ Computation ∩ Qubiut ∉ InputQubit set  → δᵥ = ϕᵥ′ + θᵥ + rᵥπ\n\n\n\n\n\n","category":"function"},{"location":"#Helper-functions","page":"Home","title":"Helper functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    get_ratio_between_two_types","category":"page"},{"location":"#RobustVerificationSimulator.get_ratio_between_two_types","page":"Home","title":"RobustVerificationSimulator.get_ratio_between_two_types","text":"Get ratio of occurence between two types\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    rand_int","category":"page"},{"location":"#RobustVerificationSimulator.rand_int","page":"Home","title":"RobustVerificationSimulator.rand_int","text":"Draw random integer either 0 or 1\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    probability_asser","category":"page"},{"location":"#RobustVerificationSimulator.probability_asser","page":"Home","title":"RobustVerificationSimulator.probability_asser","text":"Assert that a number is between 0 and 1 and asserts that \nthis true.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"    error_call_not_test_computation","category":"page"},{"location":"#RobustVerificationSimulator.error_call_not_test_computation","page":"Home","title":"RobustVerificationSimulator.error_call_not_test_computation","text":"Call if the condition of Test or Computation is not meant\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"protocol_version_01/#Protocol-prototype-version-01","page":"First protocol attemps","title":"Protocol prototype version 01","text":"","category":"section"},{"location":"protocol_version_01/","page":"First protocol attemps","title":"First protocol attemps","text":"This is a simple script I developed to get familiar the protocol ideas.","category":"page"},{"location":"protocol_version_01/","page":"First protocol attemps","title":"First protocol attemps","text":"using Pkg\nPkg.activate(\".\")\n\nusing Statistics \nusing CairoMakie\n\n\nstruct Test end\nstruct Computation end\nstruct Ok end\nstruct Abort end\nstruct Redo end\n\n// # Functions\n\n    \"\"\"\n        Assert that a number is between 0 and 1 and asserts that \n        this true.\n    \"\"\"\n    function probability_asser(p)\n        return @assert 0 <= p <= 1 \"InputQubit must be a probability (between 0 and 1), not $(p)\"\n    end\n\n\n    \"\"\" \n    Call if the condition of Test or Computation is not meant\n    \"\"\"\n    function error_call_not_test_computation()\n        return error(\"This error emerges as an if-then-else statement failed the if and the elseif parts.\")\n    end\n\n\n\n    \"\"\"\n        InputQubit a probability -> Union{TestRound,ComputationRound}\n    \"\"\"\n    function choose_test_computation(p)\n        probability_asser(p)\n        u = rand()\n        if u < p\n            return TestRound()\n        elseif u >=p\n            return ComputationRound()\n        else\n            error_call_not_test_computation()\n        end\n    end\n\n\n    \"\"\"\n        InputQubit a probability -> Union{OK,Abort}\n    \"\"\"\n    function return_ok_or_abort(p)\n        probability_asser(p)\n        u = rand()\n        if u < p\n            return Ok()\n        elseif u >=p\n            return Abort()\n        else\n            error_call_not_test_computation()\n        end\n    end\n\n    \"\"\"\n        InputQubit two proabailites (u,p) -> u\n        If uₜₑₛₜ < p -> draw new u ~ U(0,1)\n        else return u \n    \"\"\"\n    function do_redo(u,p)\n        probability_asser(p)\n        uₜₑₛₜ = rand()\n        if uₜₑₛₜ < p\n            return rand()\n        elseif uₜₑₛₜ >=p\n            return u\n        else\n            error_call_not_test_computation()\n        end\n    end\n\n\n    \"\"\"\n        Return abort with redo option\n        (Redo(),p₁,p₂) -> Union{Ok,Abort}\n        p₁ is to detemine result in Ok or Abort\n        p₂ is to determine if we do a Redo\n        which at the moment just redraws the uniform \n    \"\"\"\n\n    function return_ok_or_abort(::Redo,p₁,p₂)\n        probability_asser(p)\n        u = rand()\n        u = do_redo(u,p)\n        if u < p\n            return Ok()\n        elseif u >=p\n            return Abort()\n        else\n            error_call_not_test_computation()\n        end\n    end\n    \"\"\"\n    Take (round_type,p) -> Union{OK,Abort}\n    \"\"\"\n    function get_round_result(round_type,p)\n        if round_type isa Test\n            return return_ok_or_abort(p)\n        elseif round_type isa Computation\n            return return_ok_or_abort(p)\n        else\n            error_call_not_test_computation()\n        end\n    end\n\n\n    \"\"\"\n    Get ratio of occurence between two types\n    \"\"\"\n    function get_ratio_between_two_types(types_vec,types_test)\n\n        N = length(types_vec)\n\n        count_of_type1 = sum(map(r -> r isa typeof(types_test[1]),types_vec))\n        count_of_type2 = sum(map(r -> r isa typeof(types_test[2]),types_vec))\n\n        ratio_of_type1 = count_of_type1/N\n        ratio_of_type2 = count_of_type2/N\n        type1_str = replace(string(types_test[1]),\"()\"=>\"\")\n        type2_str = replace(string(types_test[2]),\"()\"=>\"\")\n\n        results = (\n            type1 = (type1_str,ratio_of_type1),\n            type2 = (type2_str, ratio_of_type2))\n        return results\n    end\n\n\n\n//\n\n\n\n// # Version 01 \n    p₁ = p₂ = 0.5\n    N = 1000\n    rounds = map(x -> choose_test_computation(p),1:N)\n    test_comp_types = [TestRound(),ComputationRound()]\n    rounds = map(x -> choose_test_computation(p₁),1:N)\n    test_com_ratio = get_ratio_between_two_types(rounds,test_comp_types)\n\n\n    \n\n    \"\"\"\n        Bar plot for a single iteration of N rounds.\n        Count number of tests and computations.\n        Return proportion as a barplot.\n    \"\"\"\n    f = Figure(resolution = (800,600))\n    xs = [1,2]\n    ys = [ratio_of_tests,ratio_of_computations]\n    types = [\"Test\",\"Computation\"]\n    ax = Axis(\n        f[1,1],\n        xlabel = \"Type\",ylabel=\"proportion\",\n        xticks = (xs, types),\n        title = \"Proportion of tests to computations\")\n    barplot!(ax,xs,ys)\n    f\n//\n\n\n\n// # Version 02\np₁ = p₂ = 0.5\nN = 1000\ntest_comp_types = [TestRound(),ComputationRound()]\nabort_ok_types = [Abort(),Ok()]\n\nrounds = map(x -> choose_test_computation(p₁),1:N)\nresults = map(r -> get_round_result(r,p₂),rounds)\nabort_ok_ratio = get_ratio_between_two_types(results,abort_ok_types)\n\n\n    \"\"\"\n        Bar plot for a single iteration of N rounds.\n        Count number of aborts and oks\n        Return proportion as a barplot.\n    \"\"\"\n    f = Figure(resolution = (800,600))\n        xs = [1,2]\n        xs_tick = [abort_ok_ratio[1][1],abort_ok_ratio[2][1]]\n        ys = [abort_ok_ratio[1][2],abort_ok_ratio[2][2]]\n        ax = Axis(\n            f[1,1],\n            xlabel = \"Type\",ylabel=\"proportion\",\n            xticks = (xs, xs_tick),\n            title = \"Proportion of $(xs_tick[1]) to $(xs_tick[2])\")\n        barplot!(ax,xs,ys)\n    f\n//\n\n\n// # Test redo\n    samesies = []\n    p = 0.5        \n    for i in 1:N\n        u₁ = rand()\n        u₂ = do_redo(u₁,p)\n        res = u₁ == u₂\n        push!(samesies,res)\n    end\n\n    \n    B = [(i, count(==(i), samesies)/N) for i in unique(samesies)]\n\n    \"\"\"\n        Server and Client perform same sub-protocol\n        Client sends |V| -> Server\n        \n\n    \"\"\"\n\n\n//\n\n","category":"page"},{"location":"learning_brakets/#Learning-to-use-BraKets-in-Julia","page":"Learning to use QBase.jl","title":"Learning to use BraKets in Julia","text":"","category":"section"},{"location":"learning_brakets/","page":"Learning to use QBase.jl","title":"Learning to use QBase.jl","text":"There is a package QBase which will allow one to implelement the Dirac notation. These functions will be included in the package once I am ready to do so.","category":"page"},{"location":"learning_brakets/","page":"Learning to use QBase.jl","title":"Learning to use QBase.jl","text":"\nusing Pkg\nPkg.activate(\".\")\nusing QBase\n\nstruct TrigIdentity end\n\nfunction euler_identity(::TrigIdentity,ϕ)\n    return cos(ϕ) + Complex(0,1)*sin(ϕ)\nend\n\nfunction bra_ket_plus(::TrigIdentity,ϕ)\n    ψ = (1/√2) .* (Ket([1,0]) + euler_identity(TrigIdentity(),ϕ)*Ket([0,1]))\n    ψ = Ket(ψ)\n    return ψ*ψ'\nend\n\nfunction bra_ket_minus(::TrigIdentity,ϕ)\n    ψ = (1/√2) .* (Ket([1,0]) - euler_identity(TrigIdentity(),ϕ)*Ket([0,1]))\n    ψ = Ket(ψ)\n    return ψ*ψ'\nend\n\nfunction get_state_from_angle(ϕ)\n    ψ = (1/√2) .* (Ket([1,0]) + euler_identity(TrigIdentity(),ϕ)*Ket([0,1]))\n    return Ket(ψ)\nend\n\nfunction get_conj_perp(ψ)\n    ψ₁ = adjoint(ψ)\n    ψ⊥ = Ket([ψ₁[2], -ψ₁[1]])\n    return ψ⊥\nend\n\nfunction measure_according_state(ψ,ψ⊥)\n    return (Bra(ψ)*(ψ*ψ' - ψ⊥*ψ⊥')*ψ)[1]\nend\n\nϕ = π/4 \nψ = get_state_from_angle(ϕ)\nM₀ = bra_ket_plus(TrigIdentity(),ϕ)\nM₁ = bra_ket_minus(TrigIdentity(),ϕ)\n\n\n\nfunction measuare_from_angle(ϕ)\n    ψ = get_state_from_angle(ϕ)\n    ψ⊥ = get_conj_perp(ψ)\n    meas_ϕ = measure_according_state(ψ,ψ⊥)\n    meas_ϕ = round(meas_ϕ,digits=0)\n    return meas_ϕ\nend \n\nrand_ϕ() = rand([0,7])*π/4\n\nres = [measuare_from_angle(rand_ϕ()) for i in 1:1000]\n\n\n\n\nM₁ == M₁^2\nM₀^2 + M₁^2\n\n\nPOVM(M₀)\nψ == adjoint(ψ)\n\nadjoint(M₀)*M₀ + adjoint(M₁)*M₁\n\nBra(ψ)*M₀*ψ\nBra(ψ)*M₁*ψ\n\n(M₀*ψ)/sqrt((Bra(ψ)*adjoint(M₀)*M₀*ψ)[1].re)\n\nBra([1,0]) == adjoint(Ket([1,0]))\n","category":"page"}]
}
